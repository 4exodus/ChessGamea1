import { useState, useEffect, useCallback } from 'react';
import { Chess, Move } from 'chess.js';
import { useChessContext } from '../context/ChessContext';
import { getStockfishMove, getPositionAnalysis, initializeStockfish, cleanup } from '../utils/stockfish';

export function useChessEngine() {
  const { game, setGame, setAnalysis } = useChessContext();
  const [difficulty, setDifficulty] = useState(2);
  const [thinking, setThinking] = useState(false);
  const [engineReady, setEngineReady] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [playerColor, setPlayerColor] = useState<'w' | 'b' | null>(null);
  const [thinkingTime, setThinkingTime] = useState(3);

  // Initialize the chess engine
  useEffect(() => {
    let mounted = true;

    const initEngine = async () => {
      try {
        setError(null);
        await initializeStockfish();
        if (mounted) {
          setEngineReady(true);
        }
      } catch (error) {
        if (mounted) {
          const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
          console.error('Engine initialization error:', errorMessage);
          setError(`Failed to initialize chess engine: ${errorMessage}`);
        }
      }
    };

    initEngine();

    return () => {
      mounted = false;
      cleanup();
    };
  }, []);

  // Make computer move if it's its turn at game start
  useEffect(() => {
    if (engineReady && playerColor && game.turn() !== playerColor && !thinking && !game.isGameOver()) {
      makeComputerMove();
    }
  }, [engineReady, playerColor, game]);

  // Handle computer moves
  const makeComputerMove = async () => {
    if (!engineReady || thinking || game.turn() === playerColor || game.isGameOver()) return;

    try {
      setThinking(true);
      setError(null);

      // Don't make a move if the game is over
      if (game.isGameOver()) {
        setThinking(false);
        return;
      }

      // Add delay based on thinking time setting
      await new Promise(resolve => setTimeout(resolve, thinkingTime * 1000));

      const bestMove = await getStockfishMove(game.fen(), difficulty);
      if (bestMove) {
        const newGame = new Chess(game.fen());
        const moveResult = newGame.move({
          from: bestMove.slice(0, 2) as any,
          to: bestMove.slice(2, 4) as any,
          promotion: bestMove.length > 4 ? bestMove[4] as any : undefined,
        });

        if (!moveResult) {
          throw new Error('Invalid move generated by engine');
        }

        setGame(newGame);
        
        // Update analysis after the move
        if (!newGame.isGameOver()) {
          const analysis = await getPositionAnalysis(newGame.fen(), difficulty);
          setAnalysis(analysis);
        } else {
          setAnalysis(getGameEndMessage(newGame));
        }
      }
    } catch (error) {
      // Only set error if it's not a game over situation
      if (!game.isGameOver()) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        console.error('Engine move error:', errorMessage);
        setError(`Engine error: ${errorMessage}`);
      }
    } finally {
      setThinking(false);
    }
  };

  // Handle player moves
  const makeMove = useCallback(async (move: Move): Promise<boolean> => {
    if (!engineReady || thinking || !playerColor || game.turn() !== playerColor) {
      return false;
    }

    try {
      const newGame = new Chess(game.fen());
      const result = newGame.move(move);
      
      if (!result) {
        setError('Invalid move attempted');
        return false;
      }

      setGame(newGame);
      setError(null);

      // Check for game end conditions immediately after the move
      if (newGame.isGameOver()) {
        setAnalysis(getGameEndMessage(newGame));
        return true;
      }

      // Get position analysis
      const analysis = await getPositionAnalysis(newGame.fen(), difficulty);
      setAnalysis(analysis);

      // Make computer move if game isn't over
      setTimeout(() => {
        makeComputerMove();
      }, 100);
      
      return true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      console.error('Move error:', errorMessage);
      setError(`Move error: ${errorMessage}`);
      return false;
    }
  }, [game, difficulty, engineReady, thinking, playerColor, setGame, setAnalysis]);

  // Reset the game
  const resetGame = useCallback(() => {
    const newGame = new Chess();
    setGame(newGame);
    setAnalysis('Game started! Make your move.');
    setError(null);
    
    // If playing as black, make computer move
    if (playerColor === 'b' && engineReady && !thinking) {
      setTimeout(() => {
        makeComputerMove();
      }, 500);
    }
  }, [setGame, setAnalysis, playerColor, engineReady, thinking]);

  return {
    game,
    difficulty,
    setDifficulty,
    thinking,
    engineReady,
    error,
    onPlayerMove: makeMove,
    resetGame,
    playerColor,
    setPlayerColor,
    thinkingTime,
    setThinkingTime,
  };
}

function getGameEndMessage(game: Chess): string {
  if (game.isCheckmate()) {
    return `Checkmate! ${game.turn() === 'w' ? 'Black' : 'White'} wins!`;
  }
  if (game.isDraw()) {
    if (game.isStalemate()) {
      return 'Draw by stalemate';
    }
    if (game.isThreefoldRepetition()) {
      return 'Draw by threefold repetition';
    }
    if (game.isInsufficientMaterial()) {
      return 'Draw by insufficient material';
    }
    return 'Draw by fifty-move rule';
  }
  return '';
}